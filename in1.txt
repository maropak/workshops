1. DESIGN PATTERNS
- SOLID
- IMMUTABLE, how to make it
- template vs strategy 
- how to make singleton ?
- web design patterns
- some enterprise design patterna


1. JAVA SIMPLE
- how hashmap/hash set works
- array list vs linked list
-- queue, linked better insert (why), array - access by index
- kind of tree
-- what needed to put to tree map, 
-- hashmap vs hashtable

2. JAVA ADVANCED
- what is reflection
- kinds of synchronization, what bettter, what give us lock additionally 
- kinds of ExecutorService
- concurency map vs synchronized
- lock na static, na obiekt, czy sie blokuja wzejemnie 

3. SPRING SIMPLE
- what it is and why we use it, some modules
- kinds of configuration
-- xml, java, component scan, how it works
- kinds of beans
- beans annotations
- initialization, destruction methods
4. SPRING ADVANCED
- how aspects works, 
- how request bean is injected to singleton

- rodzaje powiązań xml, java, component scan
6. XML
- xpath, xquery, dom, sax (differences), jax b
9.
- what give us mock
-- separation, result which we need for test, called with specyfic parameters, veryfi that called
------------------------------------------------
TOOLS.
maven, git, git flow
- i have in master commit with hash 000, 111, 222 , want remove 111, how to solve it 
-- new branch from master
-- back to 000 on master
-- cherry pick 


+2. 
book/author
- all books (title) of author ABC
- kartesian, join
3.
incomes
usr_id | income

- wszyscy co mają przychody większe niż 10000; - chcemy id i jakie przychodzy

SELECT usr_id, sum(income)
FROM incomes
GROUP BY usr_id
HAVING sum(income) > 10000
4.


SOME LAMBDA 
- list of strings, only start from "a", as uppercase, as one string with , as selector delimiter
-- list.stream().filter(x -> x.startWIth("a"))map(x -> x.toUpperCase()).collect(Collectors.joining(", "));
- findAny, findFirst, wat return, when difference, when we use one, when other
-- Optional, difference with parallel, if first needed - use first, but slower than any
- advanced :
Map<String, List<String>> - surname, name
- only with surname == "abc", 
result Map<Integer, List<String>> - length, list with length
Map<Integer, String> map = map.entrySet().stream().filter(entry -> entry.key().equals("abc"))
.flatMap(entry -> entry.value().stream()).collect(Collectors.groupingBy(String::length));
-- if set - collect(Collectors.groupingBy(String::length,Collectors.toSet()));
-- set, tree map - ohMy.collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));

ALG SIMPLE
- how to make string start from capital letter
ALG ADVANCED
- 2 words anagrams - the best O(1), edge cases 
