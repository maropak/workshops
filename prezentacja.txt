WHat is Vault?
- keepe encrypted secrets like passwords
- different types of authentication
- different backends to keep secrets 
- flexible politics system - token has access for specyfic paths (read/write/create/delete)
- data encrypten and put to backend can by only decrypted in Vault
- ability to encrypt data in fly 
- access to secret for specyfic time (need to be renewed)/ or only for skcript invokation (token is not kept in system )
- secret leasing, during secret creation lease_id generated, for renew/revoke secret , also lease_time returned 


INIT
- in emergency situation root also can seal/unseal
- example init.conf - 2 sections most important
storage "consul" {
  address = "127.0.0.1:8500"
  path = "vault"
}

listener "tcp" {
 address = "127.0.0.1:8200"
 tls_disable = 1
}

AUTHENTICATION
- differend backend types, for authentication (user access) (token, github,...)
- enable : vault auth-enable github
- different access for backend, (token, user/pass) 
- autorisation on Vault side (using ploitics)
- the same way secret write/read - Vault give us API, but each backend works other
- create new user with the same/less access/leasing time
- new created token inherit parent privilages, time, will be revoked when parent revoked 
- revoke system, we can revoke whole tree, automatic revocation


POLITICS
- 2 default politics, root (can do all), default
- the same format
path "secret/*" {
  capabilities = ["create"]
}

path "secret/foo" {
  capabilities = ["read"]
}

path "auth/token/lookup-self" {
  capabilities = ["read"]
}
- root add politics, can list them, read
- then politics connected with tokens/groups
- politic mapping depends on backend, for example github can add to group, under default group all users have access
- politics added to token, cannot be changed, we need to remove token and create new
-- but politics are read on real time, we can change politics 

BACKEND
-- specyfic path for example secret/ for KV (vault write secret/hello value=world), transit for transit (usually path prefix like backend name)
-- (after add leasing time, need to be renewed)
-- backend need to be mounted, we can mount the same for different paths (99% not needed)- vault mount kv
-- vault mounts - show mounted
-- sys/      system   system endpoints, used for control, policy and debugging, interaction with voult core systemem
-- unmount - all secrets removed 


Cluster
- HA and scalability, fault tolerant - provided by backend
-- bottleneck is datastore
- if storage HA, Vault automatically also
- best suppoerted by Consule (secret backend)
- many vaults, one active, other redirect to active
-- each one has others in its config, all have to be unsealed 
- vaults exchange data by db - forward (could be redirect )

Additionaly
- auits in logs (who, what access/denied)
- keys rotation
- tools for "unseal keys" encryption (during init use public keys, generated should be decrypted by specyfic users)
- SSL (keys used in vault.conf on init)
- extended help system (for mounted backends)

Demo/how it works
- start server, with specyfi configuration (show listener, in memory)
- init systep -> unseal keys/root token
-- unseal keys can be additionaly encrypted by external tools
--- used to create root token, lock voult, we can put during init how many keys we want, and how many required
--- each key should have other owner
-- root token only for initial configuration, then should be removed, and we should use tokens with specyfic politics (for specyfic paths)
- we use spring support

Demo 2
- init
- add env 
- unseal
- auth to token
- use token in app
- mount transit 
- start 2 apps
- show config (application, message translation)
- tell scenarrio (write redis/vault, send encrupted/open, receive, decrypt - write to logs) -> show in code
